import React, { useEffect, useMemo, useState, useRef } from "react";

// Pixel Guessr
// Single-file React component (default export) — Tailwind CSS classes used for styling.
// How it works (summary):
// - Choose a "daily" image deterministically using the current date as a seed.
// - The image is covered by an NxN tile grid. Each reveal removes one or more tiles (random or sequential), gradually exposing the picture.
// - Player types guesses into an input. Correct guesses end the round and show stats.
// - Limited number of reveals (e.g., 6). Score depends on how few reveals you used.
// - Progress saved to localStorage. Shareable result text generated for social sharing.

// To run:
// 1) Create a React app (Vite / CRA) with Tailwind configured.
// 2) Drop this component into your app (e.g. src/PixelGuessr.jsx) and render it in App.jsx.
// 3) Add your images into public/images/ and provide entries in the IMAGES array below.
// 4) Optionally customize the TILE_COUNT, REVEALS, and image-answer mapping.

// NOTE: This file contains placeholders for images and answers. Replace IMAGES with your own URLs and
// add accepted answers for each image.

/* --------------------------- CONFIG / ASSETS --------------------------- */

const IMAGES = [
  {
    src: "/images/daily1.jpg",
    answers: ["eiffel tower", "paris"],
    title: "Eiffel Tower (example)"
  },
  {
    src: "/images/daily2.jpg",
    answers: ["golden gate", "san francisco"],
    title: "Golden Gate (example)"
  },
  {
    src: "/images/daily3.jpg",
    answers: ["kiwi", "kiwi bird", "new zealand"],
    title: "Kiwi Bird (example)"
  }
  // Add as many as you like
];

const TILE_COUNT = 7; // tile grid is TILE_COUNT x TILE_COUNT
const MAX_REVEALS = 6; // number of reveal actions allowed

/* --------------------------- UTILS --------------------------- */

function dateToSeedString(date = new Date()) {
  // Use YYYY-MM-DD to pick the daily image
  const y = date.getUTCFullYear();
  const m = String(date.getUTCMonth() + 1).padStart(2, "0");
  const d = String(date.getUTCDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

// Simple deterministic pseudo-random based on string seed
function mulberry32(a) {
  return function () {
    var t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function seedFromString(str) {
  let h = 2166136261 >>> 0;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

/* --------------------------- COMPONENT --------------------------- */

export default function PixelGuessr() {
  const todaySeed = useMemo(() => dateToSeedString(new Date()), []);
  const rng = useMemo(() => mulberry32(seedFromString(todaySeed)), [todaySeed]);

  const imageIndex = useMemo(() => {
    if (IMAGES.length === 0) return 0;
    // Choose an index deterministically per-day
    const idx = Math.floor(rng() * IMAGES.length);
    return idx;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [todaySeed]);

  const image = IMAGES[imageIndex];

  // Create tiles (row, col)
  const totalTiles = TILE_COUNT * TILE_COUNT;

  // We'll pick a deterministic reveal order for the day's seed
  const revealOrder = useMemo(() => {
    const indices = Array.from({ length: totalTiles }, (_, i) => i);
    const shuffleRng = mulberry32(seedFromString(todaySeed + "-order"));
    for (let i = indices.length - 1; i > 0; i--) {
      const j = Math.floor(shuffleRng() * (i + 1));
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    return indices;
  }, [todaySeed, totalTiles]);

  // Game state
  const [revealsUsed, setRevealsUsed] = useState(0); // how many reveal actions player took
  const [revealedTiles, setRevealedTiles] = useState(() => new Set());
  const [guess, setGuess] = useState("");
  const [guesses, setGuesses] = useState([]);
  const [solved, setSolved] = useState(false);
  const [message, setMessage] = useState("");
  const inputRef = useRef(null);

  // Load saved state for today's game
  useEffect(() => {
    const key = `pixelguessr:${todaySeed}`;
    try {
      const raw = localStorage.getItem(key);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (parsed?.imageIndex === imageIndex) {
          setRevealsUsed(parsed.revealsUsed || 0);
          setRevealedTiles(new Set(parsed.revealedTiles || []));
          setGuesses(parsed.guesses || []);
          setSolved(parsed.solved || false);
        }
      }
    } catch (e) {
      // ignore
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [todaySeed]);

  // Save state whenever it changes
  useEffect(() => {
    const key = `pixelguessr:${todaySeed}`;
    const payload = JSON.stringify({
      imageIndex,
      revealsUsed,
      revealedTiles: Array.from(revealedTiles),
      guesses,
      solved
    });
    localStorage.setItem(key, payload);
  }, [revealsUsed, revealedTiles, guesses, solved, todaySeed, imageIndex]);

  // Reveal action: reveal N tiles per 'reveal'
  const tilesPerReveal = Math.ceil(totalTiles / MAX_REVEALS);

  function doReveal() {
    if (revealsUsed >= MAX_REVEALS || solved) return;
    const start = revealsUsed * tilesPerReveal;
    const end = Math.min(start + tilesPerReveal, totalTiles);
    const newSet = new Set(revealedTiles);
    for (let k = start; k < end; k++) {
      newSet.add(revealOrder[k]);
    }
    setRevealedTiles(newSet);
    setRevealsUsed((r) => r + 1);
    setMessage("");
  }

  function checkGuess(raw) {
    const normalized = raw.trim().toLowerCase();
    if (!normalized) return;
    setGuesses((g) => [...g, normalized]);

    const isCorrect = image.answers.some((a) => a.toLowerCase() === normalized);
    if (isCorrect) {
      setSolved(true);
      setMessage("Correct! 🎉");
      // reveal all tiles
      setRevealedTiles(new Set(revealOrder));
    } else {
      setMessage("Nope — try again.");
    }
  }

  function onSubmit(e) {
    e.preventDefault();
    checkGuess(guess);
    setGuess("");
    inputRef.current?.focus();
  }

  // Shareable summary
  function shareResult() {
    const emojiTiles = (n) => {
      let s = "";
      for (let i = 0; i < n; i++) s += "🟪"; // unrevealed
      for (let i = n; i < MAX_REVEALS; i++) s += "🟩"; // revealed
      return s;
    };

    const used = solved ? revealsUsed : MAX_REVEALS;
    const text = `PixelGuessr — ${todaySeed}\nResult: ${solved ? `Solved in ${used}` : "Failed"} (${guesses.length} guesses)\n${emojiTiles(revealsUsed)}\nPlay: <your-site-here>`;

    if (navigator.share) {
      navigator.share({ title: "PixelGuessr result", text });
    } else {
      navigator.clipboard
        .writeText(text)
        .then(() => setMessage("Result copied to clipboard — share it!"))
        .catch(() => setMessage("Could not copy — try manually."));
    }
  }

  // Reset (for testing/early development only)
  function resetToday() {
    setRevealsUsed(0);
    setRevealedTiles(new Set());
    setGuesses([]);
    setSolved(false);
    setMessage("Reset for testing.");
    localStorage.removeItem(`pixelguessr:${todaySeed}`);
  }

  /* --------------------------- RENDER --------------------------- */
  return (
    <div className="max-w-3xl mx-auto p-4">
      <header className="flex items-center justify-between mb-4">
        <h1 className="text-2xl font-extrabold">PixelGuessr</h1>
        <div className="text-sm text-zinc-500">Daily • {todaySeed}</div>
      </header>

      <main className="grid md:grid-cols-2 gap-6">
        {/* Left: image + tiles */}
        <section>
          <div className="relative bg-black rounded-lg overflow-hidden shadow-lg">
            <img
              src={image.src}
              alt={image.title || "Daily image"}
              className="w-full h-80 object-cover block"
            />

            {/* Tile overlay grid */}
            <div className="absolute inset-0 pointer-events-none">
              <div className="w-full h-full grid" style={{ gridTemplateColumns: `repeat(${TILE_COUNT}, 1fr)` }}>
                {Array.from({ length: totalTiles }, (_, i) => {
                  const revealed = revealedTiles.has(i);
                  // determine row/col for nice key
                  const r = Math.floor(i / TILE_COUNT);
                  const c = i % TILE_COUNT;
                  return (
                    <div
                      key={`${r}-${c}`}
                      className={`transition-all duration-500 ease-in-out ${revealed ? "opacity-0 scale-95" : "opacity-100"}`}
                      style={{
                        border: "1px solid rgba(255,255,255,0.03)",
                        backgroundColor: revealed ? "transparent" : "rgba(0,0,0,0.84)"
                      }}
                    />
                  );
                })}
              </div>
            </div>

            {/* faint caption */}
            <div className="absolute left-2 bottom-2 text-xs text-white/80 px-2 py-1 rounded-sm bg-black/40">
              {solved ? image.title : `Reveals used: ${revealsUsed}/${MAX_REVEALS}`}
            </div>
          </div>

          {/* Reveal and control buttons */}
          <div className="flex gap-2 mt-3">
            <button
              onClick={doReveal}
              disabled={revealsUsed >= MAX_REVEALS || solved}
              className="px-3 py-2 rounded-md bg-indigo-600 text-white disabled:opacity-50"
            >
              Reveal (+{tilesPerReveal})
            </button>

            <button
              onClick={() => {
                // give a tiny hint: reveal center tile
                if (solved) return;
                const center = Math.floor(totalTiles / 2);
                const newSet = new Set(revealedTiles);
                newSet.add(center);
                setRevealedTiles(newSet);
                setMessage("Small hint revealed.");
              }}
              className="px-3 py-2 rounded-md border"
            >
              Tiny hint
            </button>

            <button onClick={shareResult} className="px-3 py-2 rounded-md border ml-auto">
              Share
            </button>

            <button onClick={resetToday} className="px-3 py-2 rounded-md text-sm text-red-500">
              Reset
            </button>
          </div>
        </section>

        {/* Right: UI for guesses */}
        <section>
          <div className="bg-white/5 p-4 rounded-lg shadow">
            <h2 className="font-semibold">Make a guess</h2>
            <form onSubmit={onSubmit} className="mt-3 flex gap-2">
              <input
                ref={inputRef}
                value={guess}
                onChange={(e) => setGuess(e.target.value)}
                placeholder="Type your guess (place, object, person...)"
                className="flex-1 px-3 py-2 rounded-md bg-zinc-900 text-white border"
                disabled={solved}
              />
              <button type="submit" className="px-3 py-2 rounded-md bg-green-600 text-white" disabled={solved}>
                Guess
              </button>
            </form>

            <div className="mt-3 text-sm text-zinc-300">
              {message && <div className="mb-2">{message}</div>}

              <div className="mb-2">
                <strong>Guesses:</strong>
                <div className="mt-1 flex flex-wrap gap-2">
                  {guesses.length === 0 && <span className="text-zinc-500">No guesses yet</span>}
                  {guesses.map((g, i) => (
                    <span key={i} className="px-2 py-1 rounded bg-zinc-800 text-sm">
                      {g}
                    </span>
                  ))}
                </div>
              </div>

              <div className="text-xs text-zinc-400">
                Hints: Try country / city / landmark / object names. Answers are normalized (case-insensitive).
              </div>

              <div className="mt-4">
                <strong>Daily info</strong>
                <div className="text-sm text-zinc-400 mt-1">Image #{imageIndex + 1} • {image.title}</div>
              </div>

              {solved && (
                <div className="mt-4 p-3 rounded bg-green-900/20">
                  <strong>Nice!</strong>
                  <div className="text-sm">You solved the puzzle in {revealsUsed} reveal(s) and {guesses.length} guess(es).</div>
                </div>
              )}

              {!solved && revealsUsed >= MAX_REVEALS && (
                <div className="mt-4 p-3 rounded bg-red-900/10">
                  <strong>Out of reveals.</strong>
                  <div className="text-sm">The answer was: <em className="ml-1">{image.answers[0]}</em></div>
                </div>
              )}
            </div>
          </div>

          {/* small help / rules */}
          <div className="mt-4 text-sm text-zinc-400">
            <h3 className="font-semibold">Rules</h3>
            <ul className="list-disc ml-5 mt-1">
              <li>One daily puzzle. Same for everyone.</li>
              <li>You can reveal up to {MAX_REVEALS} times — each reveal uncovers parts of the image.</li>
              <li>Type guesses; exact matches using the accepted answers count as correct (you can add synonyms in IMAGES).</li>
              <li>Share your result when you're done!</li>
            </ul>

            <div className="mt-3">
              Ideas to improve: add fuzzy matching (Levenshtein), multi-language answers, timed leaderboards, streaks, social share images, and user-uploaded puzzles.
            </div>
          </div>
        </section>
      </main>

      <footer className="mt-6 text-xs text-zinc-500 text-center">
        PixelGuessr • built with ❤️ • Replace images in <code>/public/images/</code> and update IMAGES array.
      </footer>
    </div>
  );
}
